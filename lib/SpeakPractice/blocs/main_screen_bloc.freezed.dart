// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'main_screen_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass.');

/// @nodoc
mixin _$MainScreenEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() start,
    required TResult Function() stop,
    required TResult Function() restart,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? start,
    TResult? Function()? stop,
    TResult? Function()? restart,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? start,
    TResult Function()? stop,
    TResult Function()? restart,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(_Start value) start,
    required TResult Function(_Stop value) stop,
    required TResult Function(_Restart value) restart,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(_Start value)? start,
    TResult? Function(_Stop value)? stop,
    TResult? Function(_Restart value)? restart,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(_Start value)? start,
    TResult Function(_Stop value)? stop,
    TResult Function(_Restart value)? restart,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MainScreenEventCopyWith<$Res> {
  factory $MainScreenEventCopyWith(
          MainScreenEvent value, $Res Function(MainScreenEvent) then) =
      _$MainScreenEventCopyWithImpl<$Res, MainScreenEvent>;
}

/// @nodoc
class _$MainScreenEventCopyWithImpl<$Res, $Val extends MainScreenEvent>
    implements $MainScreenEventCopyWith<$Res> {
  _$MainScreenEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$MainScreenEventCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitialImpl implements Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'MainScreenEvent.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() start,
    required TResult Function() stop,
    required TResult Function() restart,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? start,
    TResult? Function()? stop,
    TResult? Function()? restart,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? start,
    TResult Function()? stop,
    TResult Function()? restart,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(_Start value) start,
    required TResult Function(_Stop value) stop,
    required TResult Function(_Restart value) restart,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(_Start value)? start,
    TResult? Function(_Stop value)? stop,
    TResult? Function(_Restart value)? restart,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(_Start value)? start,
    TResult Function(_Stop value)? stop,
    TResult Function(_Restart value)? restart,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class Initial implements MainScreenEvent {
  const factory Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$StartImplCopyWith<$Res> {
  factory _$$StartImplCopyWith(
          _$StartImpl value, $Res Function(_$StartImpl) then) =
      __$$StartImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StartImplCopyWithImpl<$Res>
    extends _$MainScreenEventCopyWithImpl<$Res, _$StartImpl>
    implements _$$StartImplCopyWith<$Res> {
  __$$StartImplCopyWithImpl(
      _$StartImpl _value, $Res Function(_$StartImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$StartImpl implements _Start {
  const _$StartImpl();

  @override
  String toString() {
    return 'MainScreenEvent.start()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StartImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() start,
    required TResult Function() stop,
    required TResult Function() restart,
  }) {
    return start();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? start,
    TResult? Function()? stop,
    TResult? Function()? restart,
  }) {
    return start?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? start,
    TResult Function()? stop,
    TResult Function()? restart,
    required TResult orElse(),
  }) {
    if (start != null) {
      return start();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(_Start value) start,
    required TResult Function(_Stop value) stop,
    required TResult Function(_Restart value) restart,
  }) {
    return start(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(_Start value)? start,
    TResult? Function(_Stop value)? stop,
    TResult? Function(_Restart value)? restart,
  }) {
    return start?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(_Start value)? start,
    TResult Function(_Stop value)? stop,
    TResult Function(_Restart value)? restart,
    required TResult orElse(),
  }) {
    if (start != null) {
      return start(this);
    }
    return orElse();
  }
}

abstract class _Start implements MainScreenEvent {
  const factory _Start() = _$StartImpl;
}

/// @nodoc
abstract class _$$StopImplCopyWith<$Res> {
  factory _$$StopImplCopyWith(
          _$StopImpl value, $Res Function(_$StopImpl) then) =
      __$$StopImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StopImplCopyWithImpl<$Res>
    extends _$MainScreenEventCopyWithImpl<$Res, _$StopImpl>
    implements _$$StopImplCopyWith<$Res> {
  __$$StopImplCopyWithImpl(_$StopImpl _value, $Res Function(_$StopImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$StopImpl implements _Stop {
  const _$StopImpl();

  @override
  String toString() {
    return 'MainScreenEvent.stop()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StopImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() start,
    required TResult Function() stop,
    required TResult Function() restart,
  }) {
    return stop();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? start,
    TResult? Function()? stop,
    TResult? Function()? restart,
  }) {
    return stop?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? start,
    TResult Function()? stop,
    TResult Function()? restart,
    required TResult orElse(),
  }) {
    if (stop != null) {
      return stop();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(_Start value) start,
    required TResult Function(_Stop value) stop,
    required TResult Function(_Restart value) restart,
  }) {
    return stop(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(_Start value)? start,
    TResult? Function(_Stop value)? stop,
    TResult? Function(_Restart value)? restart,
  }) {
    return stop?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(_Start value)? start,
    TResult Function(_Stop value)? stop,
    TResult Function(_Restart value)? restart,
    required TResult orElse(),
  }) {
    if (stop != null) {
      return stop(this);
    }
    return orElse();
  }
}

abstract class _Stop implements MainScreenEvent {
  const factory _Stop() = _$StopImpl;
}

/// @nodoc
abstract class _$$RestartImplCopyWith<$Res> {
  factory _$$RestartImplCopyWith(
          _$RestartImpl value, $Res Function(_$RestartImpl) then) =
      __$$RestartImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RestartImplCopyWithImpl<$Res>
    extends _$MainScreenEventCopyWithImpl<$Res, _$RestartImpl>
    implements _$$RestartImplCopyWith<$Res> {
  __$$RestartImplCopyWithImpl(
      _$RestartImpl _value, $Res Function(_$RestartImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$RestartImpl implements _Restart {
  const _$RestartImpl();

  @override
  String toString() {
    return 'MainScreenEvent.restart()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$RestartImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() start,
    required TResult Function() stop,
    required TResult Function() restart,
  }) {
    return restart();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? start,
    TResult? Function()? stop,
    TResult? Function()? restart,
  }) {
    return restart?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? start,
    TResult Function()? stop,
    TResult Function()? restart,
    required TResult orElse(),
  }) {
    if (restart != null) {
      return restart();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(_Start value) start,
    required TResult Function(_Stop value) stop,
    required TResult Function(_Restart value) restart,
  }) {
    return restart(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(_Start value)? start,
    TResult? Function(_Stop value)? stop,
    TResult? Function(_Restart value)? restart,
  }) {
    return restart?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(_Start value)? start,
    TResult Function(_Stop value)? stop,
    TResult Function(_Restart value)? restart,
    required TResult orElse(),
  }) {
    if (restart != null) {
      return restart(this);
    }
    return orElse();
  }
}

abstract class _Restart implements MainScreenEvent {
  const factory _Restart() = _$RestartImpl;
}

/// @nodoc
mixin _$MainScreenState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(List<String> word) generatedList,
    required TResult Function(
            String listenedValue,
            List<String> word,
            List<int> correctIndex,
            RiveAnimationController<dynamic> riveAnimationController,
            bool isListening,
            bool speechEnabled)
        listened,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(List<String> word)? generatedList,
    TResult? Function(
            String listenedValue,
            List<String> word,
            List<int> correctIndex,
            RiveAnimationController<dynamic> riveAnimationController,
            bool isListening,
            bool speechEnabled)?
        listened,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<String> word)? generatedList,
    TResult Function(
            String listenedValue,
            List<String> word,
            List<int> correctIndex,
            RiveAnimationController<dynamic> riveAnimationController,
            bool isListening,
            bool speechEnabled)?
        listened,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_GeneratedList value) generatedList,
    required TResult Function(_Listened value) listened,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loading value)? loading,
    TResult? Function(_GeneratedList value)? generatedList,
    TResult? Function(_Listened value)? listened,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_GeneratedList value)? generatedList,
    TResult Function(_Listened value)? listened,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MainScreenStateCopyWith<$Res> {
  factory $MainScreenStateCopyWith(
          MainScreenState value, $Res Function(MainScreenState) then) =
      _$MainScreenStateCopyWithImpl<$Res, MainScreenState>;
}

/// @nodoc
class _$MainScreenStateCopyWithImpl<$Res, $Val extends MainScreenState>
    implements $MainScreenStateCopyWith<$Res> {
  _$MainScreenStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$LoadingImplCopyWith<$Res> {
  factory _$$LoadingImplCopyWith(
          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =
      __$$LoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingImplCopyWithImpl<$Res>
    extends _$MainScreenStateCopyWithImpl<$Res, _$LoadingImpl>
    implements _$$LoadingImplCopyWith<$Res> {
  __$$LoadingImplCopyWithImpl(
      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadingImpl implements _Loading {
  const _$LoadingImpl();

  @override
  String toString() {
    return 'MainScreenState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(List<String> word) generatedList,
    required TResult Function(
            String listenedValue,
            List<String> word,
            List<int> correctIndex,
            RiveAnimationController<dynamic> riveAnimationController,
            bool isListening,
            bool speechEnabled)
        listened,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(List<String> word)? generatedList,
    TResult? Function(
            String listenedValue,
            List<String> word,
            List<int> correctIndex,
            RiveAnimationController<dynamic> riveAnimationController,
            bool isListening,
            bool speechEnabled)?
        listened,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<String> word)? generatedList,
    TResult Function(
            String listenedValue,
            List<String> word,
            List<int> correctIndex,
            RiveAnimationController<dynamic> riveAnimationController,
            bool isListening,
            bool speechEnabled)?
        listened,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_GeneratedList value) generatedList,
    required TResult Function(_Listened value) listened,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loading value)? loading,
    TResult? Function(_GeneratedList value)? generatedList,
    TResult? Function(_Listened value)? listened,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_GeneratedList value)? generatedList,
    TResult Function(_Listened value)? listened,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _Loading implements MainScreenState {
  const factory _Loading() = _$LoadingImpl;
}

/// @nodoc
abstract class _$$GeneratedListImplCopyWith<$Res> {
  factory _$$GeneratedListImplCopyWith(
          _$GeneratedListImpl value, $Res Function(_$GeneratedListImpl) then) =
      __$$GeneratedListImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> word});
}

/// @nodoc
class __$$GeneratedListImplCopyWithImpl<$Res>
    extends _$MainScreenStateCopyWithImpl<$Res, _$GeneratedListImpl>
    implements _$$GeneratedListImplCopyWith<$Res> {
  __$$GeneratedListImplCopyWithImpl(
      _$GeneratedListImpl _value, $Res Function(_$GeneratedListImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? word = null,
  }) {
    return _then(_$GeneratedListImpl(
      word: null == word
          ? _value._word
          : word // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$GeneratedListImpl implements _GeneratedList {
  const _$GeneratedListImpl({required final List<String> word}) : _word = word;

  final List<String> _word;
  @override
  List<String> get word {
    if (_word is EqualUnmodifiableListView) return _word;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_word);
  }

  @override
  String toString() {
    return 'MainScreenState.generatedList(word: $word)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GeneratedListImpl &&
            const DeepCollectionEquality().equals(other._word, _word));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_word));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GeneratedListImplCopyWith<_$GeneratedListImpl> get copyWith =>
      __$$GeneratedListImplCopyWithImpl<_$GeneratedListImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(List<String> word) generatedList,
    required TResult Function(
            String listenedValue,
            List<String> word,
            List<int> correctIndex,
            RiveAnimationController<dynamic> riveAnimationController,
            bool isListening,
            bool speechEnabled)
        listened,
  }) {
    return generatedList(word);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(List<String> word)? generatedList,
    TResult? Function(
            String listenedValue,
            List<String> word,
            List<int> correctIndex,
            RiveAnimationController<dynamic> riveAnimationController,
            bool isListening,
            bool speechEnabled)?
        listened,
  }) {
    return generatedList?.call(word);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<String> word)? generatedList,
    TResult Function(
            String listenedValue,
            List<String> word,
            List<int> correctIndex,
            RiveAnimationController<dynamic> riveAnimationController,
            bool isListening,
            bool speechEnabled)?
        listened,
    required TResult orElse(),
  }) {
    if (generatedList != null) {
      return generatedList(word);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_GeneratedList value) generatedList,
    required TResult Function(_Listened value) listened,
  }) {
    return generatedList(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loading value)? loading,
    TResult? Function(_GeneratedList value)? generatedList,
    TResult? Function(_Listened value)? listened,
  }) {
    return generatedList?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_GeneratedList value)? generatedList,
    TResult Function(_Listened value)? listened,
    required TResult orElse(),
  }) {
    if (generatedList != null) {
      return generatedList(this);
    }
    return orElse();
  }
}

abstract class _GeneratedList implements MainScreenState {
  const factory _GeneratedList({required final List<String> word}) =
      _$GeneratedListImpl;

  List<String> get word;
  @JsonKey(ignore: true)
  _$$GeneratedListImplCopyWith<_$GeneratedListImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ListenedImplCopyWith<$Res> {
  factory _$$ListenedImplCopyWith(
          _$ListenedImpl value, $Res Function(_$ListenedImpl) then) =
      __$$ListenedImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String listenedValue,
      List<String> word,
      List<int> correctIndex,
      RiveAnimationController<dynamic> riveAnimationController,
      bool isListening,
      bool speechEnabled});
}

/// @nodoc
class __$$ListenedImplCopyWithImpl<$Res>
    extends _$MainScreenStateCopyWithImpl<$Res, _$ListenedImpl>
    implements _$$ListenedImplCopyWith<$Res> {
  __$$ListenedImplCopyWithImpl(
      _$ListenedImpl _value, $Res Function(_$ListenedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? listenedValue = null,
    Object? word = null,
    Object? correctIndex = null,
    Object? riveAnimationController = null,
    Object? isListening = null,
    Object? speechEnabled = null,
  }) {
    return _then(_$ListenedImpl(
      listenedValue: null == listenedValue
          ? _value.listenedValue
          : listenedValue // ignore: cast_nullable_to_non_nullable
              as String,
      word: null == word
          ? _value._word
          : word // ignore: cast_nullable_to_non_nullable
              as List<String>,
      correctIndex: null == correctIndex
          ? _value._correctIndex
          : correctIndex // ignore: cast_nullable_to_non_nullable
              as List<int>,
      riveAnimationController: null == riveAnimationController
          ? _value.riveAnimationController
          : riveAnimationController // ignore: cast_nullable_to_non_nullable
              as RiveAnimationController<dynamic>,
      isListening: null == isListening
          ? _value.isListening
          : isListening // ignore: cast_nullable_to_non_nullable
              as bool,
      speechEnabled: null == speechEnabled
          ? _value.speechEnabled
          : speechEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$ListenedImpl implements _Listened {
  const _$ListenedImpl(
      {required this.listenedValue,
      required final List<String> word,
      required final List<int> correctIndex,
      required this.riveAnimationController,
      required this.isListening,
      required this.speechEnabled})
      : _word = word,
        _correctIndex = correctIndex;

  @override
  final String listenedValue;
  final List<String> _word;
  @override
  List<String> get word {
    if (_word is EqualUnmodifiableListView) return _word;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_word);
  }

  final List<int> _correctIndex;
  @override
  List<int> get correctIndex {
    if (_correctIndex is EqualUnmodifiableListView) return _correctIndex;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_correctIndex);
  }

  @override
  final RiveAnimationController<dynamic> riveAnimationController;
  @override
  final bool isListening;
  @override
  final bool speechEnabled;

  @override
  String toString() {
    return 'MainScreenState.listened(listenedValue: $listenedValue, word: $word, correctIndex: $correctIndex, riveAnimationController: $riveAnimationController, isListening: $isListening, speechEnabled: $speechEnabled)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListenedImpl &&
            (identical(other.listenedValue, listenedValue) ||
                other.listenedValue == listenedValue) &&
            const DeepCollectionEquality().equals(other._word, _word) &&
            const DeepCollectionEquality()
                .equals(other._correctIndex, _correctIndex) &&
            (identical(
                    other.riveAnimationController, riveAnimationController) ||
                other.riveAnimationController == riveAnimationController) &&
            (identical(other.isListening, isListening) ||
                other.isListening == isListening) &&
            (identical(other.speechEnabled, speechEnabled) ||
                other.speechEnabled == speechEnabled));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      listenedValue,
      const DeepCollectionEquality().hash(_word),
      const DeepCollectionEquality().hash(_correctIndex),
      riveAnimationController,
      isListening,
      speechEnabled);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListenedImplCopyWith<_$ListenedImpl> get copyWith =>
      __$$ListenedImplCopyWithImpl<_$ListenedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(List<String> word) generatedList,
    required TResult Function(
            String listenedValue,
            List<String> word,
            List<int> correctIndex,
            RiveAnimationController<dynamic> riveAnimationController,
            bool isListening,
            bool speechEnabled)
        listened,
  }) {
    return listened(listenedValue, word, correctIndex, riveAnimationController,
        isListening, speechEnabled);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(List<String> word)? generatedList,
    TResult? Function(
            String listenedValue,
            List<String> word,
            List<int> correctIndex,
            RiveAnimationController<dynamic> riveAnimationController,
            bool isListening,
            bool speechEnabled)?
        listened,
  }) {
    return listened?.call(listenedValue, word, correctIndex,
        riveAnimationController, isListening, speechEnabled);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<String> word)? generatedList,
    TResult Function(
            String listenedValue,
            List<String> word,
            List<int> correctIndex,
            RiveAnimationController<dynamic> riveAnimationController,
            bool isListening,
            bool speechEnabled)?
        listened,
    required TResult orElse(),
  }) {
    if (listened != null) {
      return listened(listenedValue, word, correctIndex,
          riveAnimationController, isListening, speechEnabled);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_GeneratedList value) generatedList,
    required TResult Function(_Listened value) listened,
  }) {
    return listened(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loading value)? loading,
    TResult? Function(_GeneratedList value)? generatedList,
    TResult? Function(_Listened value)? listened,
  }) {
    return listened?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_GeneratedList value)? generatedList,
    TResult Function(_Listened value)? listened,
    required TResult orElse(),
  }) {
    if (listened != null) {
      return listened(this);
    }
    return orElse();
  }
}

abstract class _Listened implements MainScreenState {
  const factory _Listened(
      {required final String listenedValue,
      required final List<String> word,
      required final List<int> correctIndex,
      required final RiveAnimationController<dynamic> riveAnimationController,
      required final bool isListening,
      required final bool speechEnabled}) = _$ListenedImpl;

  String get listenedValue;
  List<String> get word;
  List<int> get correctIndex;
  RiveAnimationController<dynamic> get riveAnimationController;
  bool get isListening;
  bool get speechEnabled;
  @JsonKey(ignore: true)
  _$$ListenedImplCopyWith<_$ListenedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
